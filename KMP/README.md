# KMP 알고리즘

+ 문자열을 검색함에 있어 빠르게 검색하기 위한 문자열 검색 알고리즘이다.
+ 비교할 필요가 없는 부분을 찾아 그 부분을 뛰어넘어 여러 칸을 이동하면서 계산 시간을 빠르게 할 수 있다.

> <h3>접두부와 접미부

+ 접두부 : 문자열의 앞부분 문자열
+ 접미부 : 문자열의 뒷부분 문자열
+ 예를 들어 **BAABAA** 라는 문자열이 있다고 하자.
+ 이 문자열의 접두부와 접미부의 모든 경우의 수는 아래와 같다.

![image](https://user-images.githubusercontent.com/43658658/117923739-8f10a680-b32f-11eb-9104-071fdc29a26a.png)

+ KMP 알고리즘은 **접두부와 접미부가 같은 부분 문자열**을 이용한다.

> <h3>KMP 알고리즘 동작 방식

+ 전체 문자열 BABCABABAABABAA 중에서 BAABABAA 문자열을 찾는다고 하자.

![image](https://user-images.githubusercontent.com/43658658/117924791-41953900-b331-11eb-8862-65bb8fdd6138.png)

+ [Step 1] 찾는 문자열을 제일 왼쪽에 놓고 전체 문자열과 비교해 다른 부분을 찾는다.
  + 찾는 문자열 기준으로 **2번 인덱스**에서 다른 문자가 확인되었다.
  + **2번 인덱스 앞부분의 문자열**이 접두부와 접미부가 같은 것이 있을 경우, 접두부 길이가 최대가 될 수 있는 경우를 찾고 접두부 길이를 구한다.
  + 현재 Step의 경우에는 **접두부와 접미부가 같은 경우가 없으므로 길이는 0이다.**

![image](https://user-images.githubusercontent.com/43658658/117925916-e106fb80-b332-11eb-9fde-9203843831e6.png)

+ [Step 2] 찾는 문자열 기준 다른 문자가 확인되는 인덱스 번호(2) - 최대 접두부 길이(0) = 2 만큼 오른쪽으로 이동한다.
  + 찾는 문자열 기준으로 **1번 인덱스**에서 다른 문자가 확인되었다.
  + **1번 인덱스 앞부분의 문자열**이 접두부와 접미부가 같은 것이 있을 경우, 접두부 길이가 최대가 될 수 있는 경우를 찾고 접두부 길이를 구한다.
  + 현재 Step의 경우에는 **접두부와 접미부가 같은 경우가 없으므로 길이는 0이다.**

![image](https://user-images.githubusercontent.com/43658658/117926091-2d523b80-b333-11eb-833e-1e4f14081dca.png)

+ [Step 3] 찾는 문자열 기준 다른 문자가 확인되는 인덱스 번호(1) - 최대 접두부 길이(0) = 1 만큼 오른쪽으로 이동한다.
  + 찾는 문자열 기준으로 **0번 인덱스**에서 다른 문자가 확인되었다.
  + **0번 인덱스 앞부분의 문자열**이 접두부와 접미부가 같은 것이 있을 경우, 접두부 길이가 최대가 될 수 있는 경우를 찾고 접두부 길이를 구한다.
  + 현재 Step의 경우에는 **0번 인덱스 앞의 문자열이 없으므로 최대 접두부 길이를 -1로 한다.**

![image](https://user-images.githubusercontent.com/43658658/117926243-6be7f600-b333-11eb-986a-8d5cc918d9c2.png)

+ [Step 4] 찾는 문자열 기준 다른 문자가 확인되는 인덱스 번호(0) - 최대 접두부 길이(-1) = 1 만큼 오른쪽으로 이동한다.
  + 찾는 문자열 기준으로 **0번 인덱스**에서 다른 문자가 확인되었다.
  + **0번 인덱스 앞부분의 문자열**이 접두부와 접미부가 같은 것이 있을 경우, 접두부 길이가 최대가 될 수 있는 경우를 찾고 접두부 길이를 구한다.
  + 현재 Step의 경우에는 **0번 인덱스 앞의 문자열이 없으므로 최대 접두부 길이를 -1로 한다.**

![image](https://user-images.githubusercontent.com/43658658/117926463-c6815200-b333-11eb-8ffa-9fa10ad6c734.png)

+ [Step 5] 찾는 문자열 기준 다른 문자가 확인되는 인덱스 번호(0) - 최대 접두부 길이(-1) = 1 만큼 오른쪽으로 이동한다.
  + 찾는 문자열 기준으로 **2번 인덱스**에서 다른 문자가 확인되었다.
  + **2번 인덱스 앞부분의 문자열**이 접두부와 접미부가 같은 것이 있을 경우, 접두부 길이가 최대가 될 수 있는 경우를 찾고 접두부 길이를 구한다.
  + 현재 Step의 경우에는 **접두부와 접미부가 같은 경우가 없으므로 길이는 0이다.**

![image](https://user-images.githubusercontent.com/43658658/117926563-eadd2e80-b333-11eb-9b0e-f8e182661f19.png)

+ [Step 6] 찾는 문자열 기준 다른 문자가 확인되는 인덱스 번호(2) - 최대 접두부 길이(0) = 2 만큼 오른쪽으로 이동한다.
  + 찾는 문자열 기준으로 **모든 문자열이 일치**한다. 일치하는 문자열 개수 +1
  + 앞부분의 문자열이 접두부와 접미부가 같은 것이 있을 경우, 접두부 길이가 최대가 될 수 있는 경우를 찾고 접두부 길이를 구한다.
  + 현재 Step의 경우에는 **접두부 BAA, 접미부 BAA가 같고 길이가 최대이므로 최대 접두부 길이는 3이다.**

![image](https://user-images.githubusercontent.com/43658658/117926690-1c55fa00-b334-11eb-9b5e-d15deaeef60c.png)

+ [Step 7] 찾는 문자열의 길이(8) - 최대 접두부 길이(3) = 5 만큼 오른쪽으로 이동한다.

![image](https://user-images.githubusercontent.com/43658658/117927483-3b08c080-b335-11eb-967e-0b64e30da383.png)

+ [Step 8] 전체 문자열을 벗어났으므로 종료한다.

+ [결과] 일치하는 문자열 갯수 : 1개
