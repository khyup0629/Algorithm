# 문제 풀이 아이디어
# 1. 주어진 수열을 양수, 음수, 0이 존재하는지 여부로 나눈다.
# 2. 음수 배열은 내림차순, 양수 배열은 오름차순으로 정렬한다.(절댓값이 큰 수가 마지막으로 가도록한다)
# 3. 큰 수부터 두 수씩 묶어서 곱해야 더한 값이 최대가 된다.
# 4. 음수는 더하면 무조건 손해이므로 최대한 묶을 수 있는 만큼 묶어서 양수로 만들어줘야한다.
# 5. 음수를 2묶음씩 곱하다가 마지막 남은 수가 하나 있을 때
#    주어진 수열에 0이 존재한다면 : 0과 짝지어줘서 음수를 없앤다.
#    주어진 수열에 0이 존재하지 않는다면 : 그냥 그 수를 결괏값에 더한다.
# 6. 양수를 2묶음씩 곱하다가 마지막 남은 수가 하나 있을 때 그냥 더한다.
# 7. 2번째로 뽑아낸 수가 1이라면, 묶지 말고 첫번째 수와 두번째 수를 각각 결괏값에 더한다.
# (양수에서 뽑아낸 수가 1이라면 그냥 결괏값에 더한다는 의미이다)
# 8. 주어진 수열에서 0은 몇 개가 있어도 상관없다. 있는지 여부가 중요한 것이다.
n = int(input())

num_pos = []  # 양수 배열 저장
num_neg = []  # 음수 배열 저장
o_exist = False  # 0이 있는지 여부
for _ in range(n):
    a = int(input())
    # 1. 주어진 수열을 양수, 음수, 0이 존재하는지 여부로 나눈다.
    if a == 0:  # 0이 있는지
        o_exist = True
    elif a < 0:  # 음수
        num_neg.append(a)
    else:  # 양수
        num_pos.append(a)
# 2. 음수 배열은 내림차순, 양수 배열은 오름차순으로 정렬한다.(절댓값이 큰 수가 마지막으로 가도록한다)
num_neg.sort(reverse=True)
num_pos.sort()
# 3. 큰 수부터 두 수씩 묶어서 곱해야 더한 값이 최대가 된다.
result = 0
# 4. 음수는 더하면 무조건 손해이므로 최대한 묶을 수 있는 만큼 묶어서 양수로 만들어줘야한다.
while num_neg:
    # 5. 음수를 2묶음씩 곱하다가 마지막 남은 수가 하나 있을 때
    x1 = num_neg.pop()
    if not num_neg:
        # 주어진 수열에 0이 존재한다면
        if o_exist:
            # 0과 짝지어줘서 음수를 없앤다.
            # 결과적으로 0이 더해지므로 결괏값은 변하지 않는다.
            break
        # 주어진 수열에 0이 존재하지 않는다면
        else:
            result += x1  # 그냥 그 수를 결괏값에 더한다.
            break
    x2 = num_neg.pop()
    result += (x1 * x2)

while num_pos:
    x1 = num_pos.pop()
    # 6. 양수를 2묶음씩 곱하다가 마지막 남은 수가 하나 있을 때 그냥 더한다.
    if not num_pos:
        result += x1
        break
    x2 = num_pos.pop()
    # 7. 2번째로 뽑아낸 수가 1이라면
    if x2 == 1:
        # 묶지 말고 첫번째 수와 두번째 수를 각각 결괏값에 더한다.
        result += (x1 + x2)
    else:
        result += (x1 * x2)

print(result)

# 문제 : https://www.acmicpc.net/problem/1744
