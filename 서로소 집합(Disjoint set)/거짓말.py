# 생소한 유형의 입력값과 union을 어떻게 묶어줄지에 대해 많이 고민한 문제.
# 지민이는 파티에 무조건 참가해야 하고, 파티에 참가자가 없으면 무조건 거짓말을 할 수 있으므로 +1

import sys
sys.setrecursionlimit(10**5)

n, m = map(int, input().split())
# 부모 노드
parent = [i for i in range(n+1)]


def find(x):  # 부모 노드 찾기
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]


def union(a, b):  # 부모 노드 갱신
    a = find(a)
    b = find(b)
    parent[b] = a


truth = list(map(int, input().split()))
for i in range(1, len(truth)):
    # 진실을 아는 참가자들을 모두 묶어준다.
    union(truth[1], truth[i])

temp = []
for _ in range(m):
    party = list(map(int, input().split()))
    # party[1]부터 2짝 씩 union 을 통해 부모 노드를 기록한다.
    # 이렇게만 union 해줘도 모두 한 그룹으로 묶인다.
    # union(party[1], party[1])은 아무 변화도 없다.
    # 어떤 파티에서 진실을 아는 참가자와 모르는 참가자가 함께 참석할 경우
    # 진실을 모르는 참가자도 진실을 아는 참가자와 하나로 묶이게 된다.
    # 즉, 부모 노드가 같아진다.
    for i in range(1, len(party)):
        union(party[1], party[i])
    # 파티를 한 번 훑어주면서 그룹을 지어주고 참가 번호들을 따로 저장
    temp.append(party[1:])

cnt = m
if truth[0] != 0:
    # 참가 번호들을 다시 훑는다.
    for array in temp:
        for i in array:  # 현재 파티의 참가자들을 모두 탐색한다.
            # 진실을 아는 사람의 번호와 같은 파티에 참석했던 사람들은 모두
            # 같은 부모 노드를 갖기 때문에 진실을 아는 사람의 그룹 중
            # 첫 번째 원소하고만 비교하면 된다.
            if find(truth[1]) == find(i):
                cnt -= 1
                break
    print(cnt)
else:  # truth[0] = 0이라면 모든 파티에서 거짓말이 가능.
    print(m)

"""
문제
지민이는 파티에 가서 이야기 하는 것을 좋아한다. 파티에 갈 때마다, 지민이는 지민이가 가장 좋아하는 이야기를 한다. 
지민이는 그 이야기를 말할 때, 있는 그대로 진실로 말하거나 엄청나게 과장해서 말한다. 당연히 과장해서 이야기하는 것이 훨씬 더 재미있기 때문에, 
되도록이면 과장해서 이야기하려고 한다. 하지만, 지민이는 거짓말쟁이로 알려지기는 싫어한다. 
문제는 몇몇 사람들은 그 이야기의 진실을 안다는 것이다. 따라서 이런 사람들이 파티에 왔을 때는, 지민이는 진실을 이야기할 수 밖에 없다. 
당연히, 어떤 사람이 어떤 파티에서는 진실을 듣고, 또다른 파티에서는 과장된 이야기를 들었을 때도 지민이는 거짓말쟁이로 알려지게 된다. 
지민이는 이런 일을 모두 피해야 한다.

사람의 수 N이 주어진다. 그리고 그 이야기의 진실을 아는 사람이 주어진다. 그리고 각 파티에 오는 사람들의 번호가 주어진다. 
지민이는 모든 파티에 참가해야 한다. 이때, 지민이가 거짓말쟁이로 알려지지 않으면서, 
과장된 이야기를 할 수 있는 파티 개수의 최댓값을 구하는 프로그램을 작성하시오.

입력
첫째 줄에 사람의 수 N과 파티의 수 M이 주어진다.

둘째 줄에는 이야기의 진실을 아는 사람의 수와 번호가 주어진다. 진실을 아는 사람의 수가 먼저 주어지고 그 개수만큼 사람들의 번호가 주어진다. 
사람들의 번호는 1부터 N까지의 수로 주어진다.

셋째 줄부터 M개의 줄에는 각 파티마다 오는 사람의 수와 번호가 같은 방식으로 주어진다.

N, M은 50 이하의 자연수이고, 진실을 아는 사람의 수와 각 파티마다 오는 사람의 수는 모두 0 이상 50 이하의 정수이다.

출력
첫째 줄에 문제의 정답을 출력한다.

예제 입력 1 
4 3
0
2 1 2
1 3
3 2 3 4
예제 출력 1 
3
예제 입력 2 
4 1
1 1
4 1 2 3 4
예제 출력 2 
0
예제 입력 3 
4 1
0
4 1 2 3 4
예제 출력 3 
1
예제 입력 4 
4 5
1 1
1 1
1 2
1 3
1 4
2 4 1
예제 출력 4 
2
예제 입력 5 
10 9
4 1 2 3 4
2 1 5
2 2 6
1 7
1 8
2 7 8
1 9
1 10
2 3 10
1 4
예제 출력 5 
4
예제 입력 6 
8 5
3 1 2 7
2 3 4
1 5
2 5 6
2 6 8
1 8
예제 출력 6 
5
예제 입력 7 
3 4
1 3
1 1
1 2
2 1 2
3 1 2 3
예제 출력 7 
0
예제 입력 8
4 3
1 1
0
4 1 2 3 4
0
예제 출력 8
2
예제 입력 9
6 5
1 6
2 1 2
2 2 3
2 3 4
2 4 5
2 5 6
예제 출력 9
0
예제 입력 10
6 5
1 6
2 4 5
2 2 1
2 2 3
2 3 4
2 5 6
예제 출력 10
0
"""