# 누적 합
# 각 층의 종유석과 석순의 개수를 누적합을 이용하면 효율적으로 계산할 수 있다.
# 종유석의 경우 거꾸로 매달려있어 인덱싱에 주의를 요해야하는데
# 종유석의 길이가 i라면, 종유석의 끝이 가리키는 층은 h - i + 1이 된다.
import sys
input = sys.stdin.readline

n, h = map(int, input().split())

down = [0] * (h + 1)
up = [0] * (h + 1)
for i in range(n):
    a = int(input())
    if i % 2 == 0:
        down[a] += 1
    else:
        # 종유석의 끝이 가리키는 층은 h - i + 1
        up[h - a + 1] += 1

# 누적 합, O(h)
# 석순은 5 -> 1, 종유석은 1 -> 5 순으로 누적 합
for i in range(2, h+1):
    # 석순은 5 -> 1
    down[h - i + 1] = down[h - i + 2] + down[h - i + 1]
    # 종유석은 1 -> 5
    up[i] = up[i-1] + up[i]

# 각 층끼리 더해준다. O(h)
destroy = []
for i in range(1, h+1):
    destroy.append(down[i] + up[i])

# 최솟값과 최솟값의 개수를 센다. O(h + h)
destroy_min = min(destroy)
print(destroy_min, destroy.count(destroy_min))

"""
문제
개똥벌레 한 마리가 장애물(석순과 종유석)로 가득찬 동굴에 들어갔다. 동굴의 길이는 N미터이고, 높이는 H미터이다. 
(N은 짝수) 첫 번째 장애물은 항상 석순이고, 그 다음에는 종유석과 석순이 번갈아가면서 등장한다.

아래 그림은 길이가 14미터이고 높이가 5미터인 동굴이다. (예제 그림)



이 개똥벌레는 장애물을 피하지 않는다. 자신이 지나갈 구간을 정한 다음 일직선으로 지나가면서 만나는 모든 장애물을 파괴한다.

위의 그림에서 4번째 구간으로 개똥벌레가 날아간다면 파괴해야하는 장애물의 수는 총 여덟개이다. 
(4번째 구간은 길이가 3인 석순과 길이가 4인 석순의 중간지점을 말한다)

하지만, 첫 번째 구간이나 다섯 번째 구간으로 날아간다면 개똥벌레는 장애물 일곱개만 파괴하면 된다.

동굴의 크기와 높이, 모든 장애물의 크기가 주어진다. 
이때, 개똥벌레가 파괴해야하는 장애물의 최솟값과 그러한 구간이 총 몇 개 있는지 구하는 프로그램을 작성하시오.

입력
첫째 줄에 N과 H가 주어진다. N은 항상 짝수이다. (2 ≤ N ≤ 200,000, 2 ≤ H ≤ 500,000)

다음 N개 줄에는 장애물의 크기가 순서대로 주어진다. 장애물의 크기는 H보다 작은 양수이다.

출력
첫째 줄에 개똥벌레가 파괴해야 하는 장애물의 최솟값과 그러한 구간의 수를 공백으로 구분하여 출력한다.

예제 입력 1 
14 5
1
3
4
2
2
4
3
4
3
3
3
2
3
3
예제 출력 1 
7 2
예제 입력 2
14 7
1
4
5
3
3
5
4
5
4
4
4
3
4
4
예제 출력 2
6 1
"""
