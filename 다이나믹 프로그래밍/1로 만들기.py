# 문제 풀이 아이디어
# 1. n까지 숫자 1부터 차례대로 dp 테이블을 갱신해 나갑니다.
# 2. n에서 나누기 3, 나누기 2, 빼기 1 중 가능한 계산을 모두 한 번씩 수행합니다.
# 3. 그리고 한 번 계산된 값을 dp 테이블의 인덱스로 넣습니다.
# 숫자 1부터 최소 계산 횟수를 dp 테이블에 저장해놓았기 때문에
# (이번 한 번의 계산 + 이전 dp 테이블 값)의 계산을 수행하면 처음 n을 3으로 나눈 뒤의 최소 계산 횟수가 계산됩니다.
# 4. 최대 3개의 계산 횟수가 생기게 되는데, 이 중 최솟값을 dp 테이블의 값으로 갱신합니다.
n = int(input())

dp = [0] * (n+1)

for i in range(2, n+1):
    cnt = []
    # n에서 3을 나눈 후의 최소 계산 횟수
    if i % 3 == 0:  # 나누기 3이 가능하면 3으로 나눕니다.
        cnt.append(dp[i // 3] + 1)  # 3으로 나눈 값을 dp 테이블의 인덱스로 넣습니다.
    # n에서 2를 나눈 후의 최소 계산 횟수
    if i % 2 == 0:  # 나누기 2가 가능하면 2로 나눕니다.
        cnt.append(dp[i // 2] + 1)  # 2로 나눈 값을 dp 테이블의 인덱스로 넣습니다.
    # n에서 1을 뺀 후의 최소 계산 횟수    
    cnt.append(dp[i-1]+1)
    dp[i] = min(cnt)  # 셋 중 최솟값을 dp 테이블 값으로 넣습니다.

print(dp[n])

# 문제 : https://www.acmicpc.net/problem/1463

# 이전 풀이 코드
n = int(input())

# DP 테이블, INF 값으로 넣어준다.
d = [int(10e6 + 1)] * (n + 1)

# DP 진행, bottom up
d[1] = 0
for i in range(2, n+1):
    # 1을 빼는 경우는 무조건 고려해야 한다.
    d[i] = d[i-1] + 1
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)

print(d[n])
