# 문제 풀이 아이디어
# 1. 연속해서 3칸을 밟으면 안되기 때문에 하나의 dp 테이블에 2개의 값을 담아야 합니다.
# - [1칸 전의 최댓값에 현재 값을 더한 값, 2칸 전의 최댓값에 현재 값을 더한 값]
# 2. 현재 인덱스에서 dp 테이블을 이용할 경우, 
# - 1칸 전의 dp 테이블 값 중 dp[index-1][1]의 값에 현재 값을 더합니다. (한 칸 이전이라면 만약 한 칸 이전 값이 그 전에도 한 칸을 거슬러 올라온 값이라면 연속해서 3칸을 밟게 됩니다)
# - 2칸 전의 dp 테이블 값 두 개 중 최댓값(max(dp[index-2]))에 현재 값을 더합니다. (두 칸 이전이라면 연속해서 3칸을 밟을 일이 없으므로 두 개의 값이 모두 고려될 수 있습니다)
# 3. 인덱스 1은 초기값을 두고 인덱스 2부터 차례대로 dp 테이블에 두 개의 정보를 기록합니다.
# 4. 마지막 인덱스 n에서 dp 테이블의 2개의 값 중 최댓값이 답이 됩니다.

n = int(input())
arr = [0]  # dp 테이블과 인덱스를 맞춰주기 위해 0인덱스에 값을 추가합니다.
for _ in range(n):
    num = int(input())
    arr.append(num)

dp = [[0, 0]] * (n+1)  # [1칸 전의 최댓값에 현재 값을 더한 값, 2칸 전의 최댓값에 현재 값을 더한 값]
dp[1] = [arr[1], arr[1]]
for i in range(2, n+1):
    # - 1칸 전의 dp 테이블 값 중 dp[index-1][1]의 값에 현재 값을 더합니다. (한 칸 이전이라면 만약 한 칸 이전 값이 그 전에도 한 칸을 거슬러 올라온 값이라면 연속해서 3칸을 밟게 됩니다)
    # - 2칸 전의 dp 테이블 값 두 개 중 최댓값(max(dp[index-2]))에 현재 값을 더합니다. (두 칸 이전이라면 연속해서 3칸을 밟을 일이 없으므로 두 개의 값이 모두 고려될 수 있습니다)
    dp[i] = [dp[i-1][1]+arr[i], max(dp[i-2])+arr[i]]

print(max(dp[n]))

# 문제 : https://www.acmicpc.net/problem/2579

# (이전 풀이)
# DP 테이블을 2개로 두고 규칙을 찾았다
# 첫 번째 계단을 안 밟는게 더 높은 점수를 받을 수 있는 경우도 있어서 고려해야한다.
# n == 2 일 때와 n > 2 일 때 [1]항에 대한 초기값을 모두 넣어줘야 한다(실수)

n = int(input())

score = []
for i in range(n):
    score.append(int(input()))
# 마지막 계단을 무조건 밟아야 하므로 거꾸로 놓는다
score.reverse()
# 첫 번째 계단을 안 밟는 경우도 고려하기 위해 시작점의 점수는 0
score.append(0)
# DP 테이블, d1은 두 칸 전 최대값 비교,
# d2는 한 칸 전 d1에 (+)
d1 = [0] * (n + 1)
d2 = [0] * (n + 1)
# DP 테이블 초기값
d1[0] = score[0]
d2[0] = score[0]
if n == 2:
    d1[1] = 0
    d2[1] = d1[0] + score[1]
elif n > 2:
    d1[1] = 0
    d2[1] = d1[0] + score[1]
    for i in range(2, n+1):
        d1[i] = max(d1[i - 2], d2[i - 2]) + score[i]
        d2[i] = d1[i - 1] + score[i]
print(max(max(d1[n - 1], d2[n - 1]), d1[n], d2[n]))
