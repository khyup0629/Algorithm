# 강한 연결 요소

+ [코사라주(Kosaraju) 알고리즘](#코사라주-Kosaraju-알고리즘)
+ [타잔(Tarjan) 알고리즘](#타잔Tarjan-알고리즘)

## 코사라주(Kosaraju) 알고리즘

1. 정방향 그래프와 역방향 그래프를 준비합니다.
2. 정방향 그래프를 이용해서 DFS 탐색을 모든 노드에서 수행합니다.
3. 스택 자료구조를 이용해 가장 마지막 노드부터 거슬러 올라오면서 스택에 추가합니다.
4. 역방향 그래프를 이용해 DFS 탐색을 스택 자료구조에서 노드를 하나씩 pop하면서 수행합니다.
5. 역방향 DFS 함수가 한 번씩 끝날 때마다 탐색한 노드의 묶음들이 각각 `강한 연결 요소`가 됩니다.

> <h3>Tip</h3>

- 방문 여부 리스트를 잘 활용해야 합니다.
  - 정뱡향, 역방향 DFS를 수행할 때 시작 노드가 미방문 상태라면 DFS를 수행합니다.

> <h3>예제</h3>

![image](https://user-images.githubusercontent.com/43658658/129837919-2a581258-50fc-4eeb-8e67-e5f585f21e75.png)

1번 노드부터 출발해서 DFS를 수행하면 4번 노드를 거쳐 5번 노드에서 더 이상 깊게 들어갈 수 없습니다. 

따라서 5, 4순으로 거슬러 올라오면서 스택 자료구조에 추가합니다.

`Stack = [5, 4]`

![image](https://user-images.githubusercontent.com/43658658/129837933-d682fc52-f8e7-4450-aeb7-343852fb672e.png)

마찬가지로 6, 7, 3, 2순으로 나머지 노드를 DFS를 수행하고 종료됩니다.

따라서 2, 3, 7, 6, 1순으로 노드들을 스택 자료구조에 추가합니다.

`Stack = [5, 4, 2, 3, 7, 6, 1]`

다음으로 역방향 그래프를 이용하여 스택에서 pop 되는 노드 순서대로 역방향 dfs 를 진행합니다. 

아래 그림과 같이 스택에서 가장 먼저 1번 노드가 pop 됩니다.

![image](https://user-images.githubusercontent.com/43658658/129838184-4ca59bc7-c3d2-4f2a-8ae3-cccd39d4f2ca.png)

1번 노드에서 역방향 그래프의 DFS를 진행하게 되면 5번 노드를 거쳐 4번 노드에서 DFS가 종료됩니다.

따라서 1, 5, 4번 노드가 `강한 연결 요소`로 묶이게 됩니다.

![image](https://user-images.githubusercontent.com/43658658/129838253-c6291ab1-8208-4b7a-a46c-8cb23a4e5d04.png)

다음으로 pop되는 6번 노드에서 DFS 탐색을 시작합니다. 하지만 6번 노드에서는 더 이상 갈 곳이 없으므로 바로 탐색이 종료됩니다.

따라서 6번 노드만이 `강한 연결 요소`가 됩니다.

![image](https://user-images.githubusercontent.com/43658658/129838314-24ec77d4-b325-46e7-ad10-0f1382c0e3ef.png)

다음으로 pop되는 7번 노드에서 DFS 탐색을 시작합니다. 3, 2번 노드를 탐색 후 DFS가 종료됩니다.

따라서 7, 3, 2번 노드가 `강한 연결 요소`로 묶이게 됩니다.

모든 요소를 한 번씩 방문했으므로 나머지 pop되는 노드들은 DFS 탐색을 수행하지 않습니다.

## 타잔(Tarjan) 알고리즘

1. 정방향 그래프를 이용해서 모든 노드들에 대해 DFS 탐색을 수행합니다.
2. 탐색되는 순서대로 해당 노드 번호에 id, low값을 0부터 1씩 증가시키며 부여합니다.
3. 탐색되는 순서대로 스택 자료구조에 노드를 추가합니다.
4. 노드에서 갈 수 있는 모든 방향의 다른 노드들을 탐색합니다.
  1. 다음 노드에 id값이 부여되지 않았을 경우, 다음 노드로 DFS 탐색에 들어갑니다.
  2. 다음 노드에 id값이 부여되었다면(순환이 발생했을 경우), 거슬러 올라오면서 다음 노드가 미방문 상태일 때, 현재 노드와 다음 노드의 low값 중 작은 값을 현재 노드의 low값으로 갱신합니다.
    - 타잔 알고리즘에서 **방문 완료**는 DFS 탐색 시점이 아닌 스택 자료구조에서 **pop된 시점**입니다.
5. 한 노드에서 갈 수 있는 모든 방향의 탐색이 끝났다면, `강한 연결 요소`를 스택 자료구조에서 pop을 통해 묶어주어야 합니다.
  1. 노드의 id값과 low값이 같은 경우 해당 노드는 어떤 사이클에서 **최고 부모 노드**임을 의미합니다.
  2. 최고 부모 노드가 스택 자료구조에서 pop이 되었을 때가 서로 다른 `강한 연결 요소`를 구분 짓는 기준점이 됩니다.
  3. 한 노드의 id값과 low값이 같은 경우 스택 자료구조에서 노드를 하나씩 pop하여 `강한 연결 요소`로 묶어줍니다.
  4. 이때 pop된 노드들의 방문 여부를 `완료`로 갱신합니다. (즉, DFS 탐색이 끝난 후에 탐색했던 모든 노드들을 방문 완료로 설정합니다)
  5. pop된 노드가 현재 노드와 같아질 경우 pop을 종료합니다.

> <h3>Tip</h3>

- 타잔 알고리즘에서 **방문 완료**는 DFS 탐색 시점이 아닌 스택 자료구조에서 **pop된 시점**입니다.
  - 즉, DFS 탐색이 끝난 후에 탐색했던 모든 노드들을 방문 완료로 설정합니다.
- 한 번 id값이 부여되면 해당 노드는 이번 DFS 탐색에서 하나 이상의 `강한 연결 요소`를 형성한다는 의미입니다.
  - 따라서 DFS 탐색의 시작점은 id값이 부여되지 않은 노드들이어야 합니다.

> <h3>예제</h3>

![image](https://user-images.githubusercontent.com/43658658/129874274-97104833-76c1-4bff-800b-60bc158656c0.png)

먼저 노드 번호에 대한 id와 low를 이런 형태로 표현하겠습니다.

방문하지 않은 노드는 파란색, 방문한 노드는 초록색으로 표시하겠습니다.

또한 사이클의 최고 부모 노드는 빨간 테두리로 표시하겠습니다.

![image](https://user-images.githubusercontent.com/43658658/129874386-20063f18-0565-4299-b791-3f0c17703e4b.png)

1번 노드부터 DFS 탐색을 시작합니다.

![image](https://user-images.githubusercontent.com/43658658/129875704-40445abe-cd75-49bc-bb26-a4092806cfd5.png)

위와 같은 순서로 탐색이 진행되며 4, 5번 노드에 id, low값이 매겨집니다.

스택 자료구조에도 역시 1, 4, 5번 순서로 저장됩니다.

`stack = [1, 4, 5]`

![image](https://user-images.githubusercontent.com/43658658/129875836-86dad328-891e-49c5-99a1-4e3203b915c3.png)

다음으로 5번 노드에서 1번 노드로 갈 때(3번 간선) 1번 노드에는 이미 id값이 매겨져 있는 상황입니다.

따라서 탐색을 수행하지 않는 대신 1번 노드는 미방문 노드이기 때문에 둘의 low값 중 작은 값을 5번 노드의 low값으로 갱신합니다.

![image](https://user-images.githubusercontent.com/43658658/129875929-ee39901c-ef17-40c3-8256-c95dd9fb000e.png)

한편 5번 노드에서는 8번 노드로 갈 수 있습니다. 8번 노드에 id, low값을 부여합니다.

`stack = [1, 4, 5, 8]`

![image](https://user-images.githubusercontent.com/43658658/129876380-e9b7856e-6a55-43cc-965a-5bac80da2333.png)

8번 노드에서는 더 이상 갈 수 있는 노드가 없습니다. 따라서 8번 노드에서의 DFS 탐색은 종료됩니다.

8번 노드는 id와 low값이 같은 최고 부모 노드입니다. 스택에서 8번 노드가 나올 때까지 pop을 시키면서 `강한 연결 요소`로 묶어주고 `방문 완료` 상태로 만들어줍니다.

![image](https://user-images.githubusercontent.com/43658658/129876924-9f8b03aa-d8e5-4a0b-8b57-0f4b5a06bd91.png)

`stack = [1, 4, 5]`

`scc = [[8]]`

다시 5번으로 돌아와 4, 1로 거슬러 내려오면서 id, low값을 갱신합니다.

![image](https://user-images.githubusercontent.com/43658658/129877246-b1b5c416-54f6-41a1-b430-7ad8a7821a8a.png)

5, 4번 노드는 DFS 탐색이 종료되었지만 id와 low값이 같지 않으므로 강한 연결 요소로 묶어주는 과정을 스킵했습니다.

1번 노드는 id와 low값이 같으므로 최고 부모 노드가 됩니다. 스택에서 1번 노드가 나올 때까지 pop을 시키면서 `강한 연결 요소`로 묶어주고 pop된 노드의 방문 상태를 `방문 완료` 상태로 만들어줍니다.

`stack = []`

`scc = [[8], [5, 4, 1]]`

1번 노드에서 일단 이번 DFS는 종료되었습니다. 다음으로 2번 노드에서 새로운 DFS 탐색이 이루어집니다.

![image](https://user-images.githubusercontent.com/43658658/129878831-353613be-2ff4-4e3b-9870-345bd195a9fb.png)

2번 노드에 id, low값을 부여합니다.

`stack = [2]`

![image](https://user-images.githubusercontent.com/43658658/129878938-2b1c90bd-8e44-4ec7-874f-15edb7ef701d.png)

DFS 탐색이 7, 3번 노드 순으로 진행되며 id, low값을 부여합니다.

`stack = [2, 7, 3]`

![image](https://user-images.githubusercontent.com/43658658/129879329-7b95e468-cb1e-4f7f-8316-24440978a5b3.png)

3번 노드에서 다시 7번 노드로 가는 방향은 7번 노드에 이미 id값이 부여되었기 때문에 갈 수 없습니다.

3번 노드의 low값은 3, 7번 노드의 low값 중 작은 값이 됩니다.

![image](https://user-images.githubusercontent.com/43658658/129880737-7c4d0813-ab69-49ca-9448-f13af37ce060.png)

3번 노드에서의 DFS 탐색은 종료되었고 7번 노드로 다시 거슬러 올라갑니다.

7번 노드에서는 아직 2번으로 탐색 방향이 남아있습니다. 하지만 2번 노드는 이미 id값이 부여되어 갈 수 없습니다.

따라서 7번 노드의 low값은 2, 7번 노드의 low값 중 작은 값이 됩니다.

![image](https://user-images.githubusercontent.com/43658658/129881009-cd1492ad-ca81-49a7-b46e-6c39b1aaec92.png)

7번 노드에서 DFS 탐색은 종료되었고, 2번 노드로 돌아왔습니다.

역시 2번 노드에서도 더 이상 갈 수 있는 방향이 없으므로 탐색이 종료됩니다.

2번 노드는 id, low값이 일치합니다. 따라서 스택에서 2번 노드가 나올 때까지 pop을 시키면서 `강한 연결 요소`로 묶어주고 pop된 노드의 방문 상태를 `방문 완료` 상태로 만들어줍니다.

`stack = []`

`scc = [[8], [5, 4, 1], [3, 7, 2]]`

![image](https://user-images.githubusercontent.com/43658658/129881272-93f3a3b7-cd63-4d08-b616-0d610bf15126.png)

6번 노드가 남았습니다. 

6번 노드에서 갈 수 있는 1, 7번 노드는 모두 id값이 부여되어 있는 상태이므로 갈 수가 없을 뿐더러 방문 완료인 상태이므로 id, low값의 갱신 또한 없습니다.

`stack = [6]`

![image](https://user-images.githubusercontent.com/43658658/129881473-220261c5-458f-41c9-b4cd-51a265de5175.png)

6번 노드의 id, low값이 일치하므로 스택에서 6번 노드가 나올 때까지 pop을 시키면서 `강한 연결 요소`로 묶어주고 pop된 노드의 방문 상태를 `방문 완료` 상태로 만들어줍니다.

`stack = []`

`scc = [[8], [5, 4, 1], [3, 7, 2], [6]]`

![image](https://user-images.githubusercontent.com/43658658/129882034-f4577c21-6066-481e-a9a6-cbe6e3fb2af5.png)

이로써 아래와 같이 강한 연결 요소가 만들어집니다.

![image](https://user-images.githubusercontent.com/43658658/129882704-233cd1c7-32ef-4ee9-a213-c099ed32c6a5.png)
